#include <utility>

using line_segment = size_t;

//+------------------------------------------------------------------+
//| gcm0                                                             |
//+------------------------------------------------------------------+

line_segment gcm0(line_segment a, line_segment b)
{
    while(a != b)
    {
        if(b < a)
        {
            a = a - b;
        }
        else
        {
            b = b - a;
        }
    }

    return a;
}

//+------------------------------------------------------------------+
//| gcm1                                                             |
//+------------------------------------------------------------------+

line_segment gcm1(line_segment a, line_segment b)
{
    while(a != b)
    {
        // Вычисление остатка -> можно вынести в отдельную функцию.
        while(b < a)
        {
            a = a - b;
        }

        std::swap(a, b);
    }

    return a;
}

//+------------------------------------------------------------------+
//| segment_remainder                                                |
//+------------------------------------------------------------------+

line_segment segment_remainder(line_segment a, line_segment b)
{
    while(b < a)
    {
        a = a - b;    
    }

    return a;
}

//+------------------------------------------------------------------+
//| Если line_segment - луч, то цикл не завершился бы.               |
//| Аксиома Архимеда:                                                |
//| Для любых двух величин a и b существует такое натуральное число  |
//| n, что  a <= nb.                                                 |
//| Означает: не существует бесконечных величин.                     |
//+------------------------------------------------------------------+

//+------------------------------------------------------------------+
//| gcm2                                                             |
//+------------------------------------------------------------------+

line_segment gcm2(line_segment a, line_segment b)
{
    while(a != b)
    {
        a = segment_remainder(a, b);

        std::swap(a, b);
    }

    return a;
}

//+------------------------------------------------------------------+
//| Улучишим segment_remainder подобно египетскому умножению         |
//| увеличивая вдвое одну величину и уменьшая вдвое другую.          |
//| Лемма о рекурсивном остатке:                                     |
//| Если r = segment_remainder(a, 2b), то                            |
//| segment_remainder(a, b) = {r если r<=b | r-b если r >b }         |
//+------------------------------------------------------------------+

//+------------------------------------------------------------------+
//| fast_segment_remainder                                           |
//+------------------------------------------------------------------+

line_segment fast_segment_remainder(line_segment a, line_segment b)
{
    // precondition: b != 0
    if(a < b)
    {
        return a;
    }

    if(a - b < b)
    {
        return a - b;
    }

    a = fast_segment_remainder(a, b + b);

    if(a < b)
    {
        return a;
    }

    return a - b;
}

//+------------------------------------------------------------------+
//| fast_segment_gcm                                                 |
//+------------------------------------------------------------------+

line_segment fast_segment_gcm(line_segment a, line_segment b)
{
    while(a != b)
    {
        a = fast_segment_remainder(a, b);

        std::swap(a, b);
    }

    return a;
}

//+------------------------------------------------------------------+
//| largest_doubling                                                 |
//| Для перехода к итеративной версии - функция кол-ва удвоений,     |
//| возваращем первый результат удвоения b, больший a - b.           |
//+------------------------------------------------------------------+

line_segment largest_doubling(line_segment a, line_segment b)
{
    //precondition: b != 0
    while(a - b >= b)
    {
        b = b + b;
    }

    return b;
}

//+------------------------------------------------------------------+
//| remainder                                                        |
//+------------------------------------------------------------------+

line_segment remainder(line_segment a, line_segment b)
{
    //precondition: b != 0
    if(a < b)
    {
        return a;
    }

    line_segment c = largest_doubling(a, b);

    a = a - c;

    while(c != b)
    {
        c = half(c);
        
        if(c <= a)
        {
            a = a - c;
        }
    }

    return a;
}

